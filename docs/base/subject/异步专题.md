# 异步专题

Created: July 12, 2021 11:52 PM
Tags: ES6, JavaScript

### 同步和异步

- 同步和异步是一种消息通知机制
- 同步：A调用B，B处理获得结果，才返回A，A继续运行
- 异步：上一件事没有做完，就可以做下一件事
    - 事件、事件、定时器、网络请求
    

### Promise

- promise 不解决异步问题，解决的是异步的写法

```jsx
new Promise(promise的回调函数，在实例化时会直接执行function(resolve,reject){
	//resolve调用该函数resolve(传递给成功的执行函数的数据)代表异步执行完成，并成功拿到结果
	//reject调用该函数reject(传递给处理失败的执行函数的数据)代表异步执行完成，但是没有成功拿到结果
}).then((成功传过来的数据)={
	console.log("成功之后业务处理")
},()={
	console.log("失败之后")
})
```

- Promise内部状态
    - Pending 在等待
    - Fulfilled（标准）|| Resolved 执行成功 - 调用resolve之后改变、
    - Rejected 执行失败 - 调用 reject 之后改变
- then
    - promise的then方法，会给我们返回一个新的Promise对象
        - 新的Promise 对象的执行状态：
            1. 默认情况下，返回一个状态为 resolved 的 Promise 对象
            2. 当then的回调函数，返回的是一个 非Promise 对象，then返回的是一个状态是resolved 的 Promise 对象
            3. 当 then 的回调函数返回的是一个 Promise 对象，then返回时，也会变成该 Promise 对象
- catch：任何一步出错都捕获

```jsx
new Promisre((resolve,reject)=>{
	reject(1)
}).then(()=>{
	console.log(1)
	return Promise.reject()  //不需要处理异步的业务，直接返回一个reject状态的Promise对象
}).then(()=>{
	console.log(2)
}).catch((err)=>{  //捕获前边的promise中出现的错误
	console.log("出错了",err)
})
```

- all：全部执行完再执行

```jsx
let p = new Promise((resolve)=>{
	setTimeout(()=>{
		console.log(1)
		resolve()
	},1000)
})
let p2 = new Promise((resolve)=>{
	setTimeout(()=>{
		console.log(2)
		resolve()
	},1000)
})
let p3 = new Promise((resolve)=>{
	setTimeout(()=>{
		console.log(3)
		resolve()
	},1000)
})
Promise.all(**[p,p2,p3]**).then(()=>{  //参数：数组
	console.log(4)
})
```

- race：只要有一项完成就执行

### 利用Promise进行封装

### Async

```jsx
async function fn(){
	let n1 = await new Promise((resolve)=>{
		setTimeout(()=>{
			console.log(1)
			resolve(10)
		},1000)
	})
	let n2 = await new Promise((resolve)=>{
		setTimeout(()=>{
			console.log(n1)
			resolve(20)
		},1000)
	})
	let n3 = await new Promise((resolve)=>{
		setTimeout(()=>{
			console.log(n2)
			resolve(30)
		},1000)
	})
	console.log(n3)
}
```