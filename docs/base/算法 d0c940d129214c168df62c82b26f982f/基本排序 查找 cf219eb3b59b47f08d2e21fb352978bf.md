# 基本排序/查找

### 选择排序

> 时间复杂度O(n^2) 空间复杂度 O(1) 稳定
> 

```java
public class selectSort {
  public static void selectSort(int[] arr) {
    if (arr == null || arr.length < 2) {
      return;
    }
    for (int i = 0; i < arr.length; i++) {
      int min = i;// 记录最小值的坐标
      for (int j = i + 1; j < arr.length; j++) {
        // 更新最小值
        min = arr[min] > arr[j] ? j : min;
      }
      // 当前位置与最小值做交换
      swap(arr, i, min);
    }
  }

  public static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }
}
```

### 冒泡排序

> 时间复杂度O(n^2) 空间复杂度O（1） 稳定
> 

```java
public class bubbleSort {
  public static void bubbleSort(int[] arr) {
    if (arr == null || arr.length < 2) {
      return;
    }
    // 两两交换，最大的往后沉
    for (int i = arr.length - 1; i >= 0; i--) {
      for (int j = 0; j < i; j++) {
        // 相邻两数做比较，最大的数一定会落到j+1处即i的位置
        if (arr[j] > arr[j + 1]) {
          swap(arr, j, j + 1);
        }
      }
    }
  }

  public static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }
}
```

### 插入排序

> 时间复杂度O（n^2） 空间复杂度O（1） 稳定
> 

```java
public class insertSort {
  public static void insertSort(int[] arr) {
    if (arr == null || arr.length < 2) {
      return;
    }
    for (int i = 0; i < arr.length; i++) {
      for (int j = i; j < 0 && arr[j] < arr[j - 1]; j--) {
        // 当前位置的值小于前一个值，交换位置
        // 直到当前位置的值大于前一个值，每次循环结束，前半截的数组是有序的
        swap(arr, j, j - 1);
      }
    }
  }

  public static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }
}
```

### 归并排序

- 递归写法

```java
// 递归写法
  public static void mergeSort1(int[] arr) {
    if (arr == null || arr.length < 2) {
      return;
    }
    process(arr, 0, arr.length - 1);
  }

  public static void process(int[] arr, int left, int right) {
    if (left == right) {
      return;
    }
    int mid = left + ((right - left) >> 1);
    // 对每一个过程，对分为左过程和右过程
    process(arr, left, mid);
    process(arr, mid + 1, right);
    // 完成后对两边进行合并
    merge(arr, left, mid, right);
  }

  // 将一个数组，左右组合并
  public static void merge(int[] arr, int left, int mid, int right) {
    int[] help = new int[arr.length];
    int index = 0;
    int L = left;
    int R = mid + 1;
    while (L <= mid && R <= right) {
      if (arr[L] <= arr[R]) {
        help[index++] = arr[L++];
      } else {
        help[index++] = arr[R++];
      }
    }
    while (L <= mid) {
      help[index++] = arr[L++];
    }
    while (R <= right) {
      help[index++] = arr[R++];
    }
    for (int item : help) {
      arr[left++] = item;
    }
  }
```

- 非递归写法

```java

```

- 小和
    - 一个数组中，一个数左边比他小的数的和叫这个数的小和，所有数的小和累加起来叫数组的小和
    
    ```java
    
    ```
    

### 快速排序

> 时间复杂度O（n）空间复杂度O（1）
> 
- 流程：小于等于则和小于区域后一个数进行交换，小于区域扩一个位置，位置后移一个；大于只把位置后移。

```java

```

### 二分查找

- 有序数组二分查找

```java
public class BinarySearch {
  public static boolean BinarySearch(int[] arr, int target) {
    if (arr == null || arr.length == 2) {
      return false;
    }
    int left = 0, right = arr.length - 1;
    while (left <= right) {
      int mid = left + (right - left) >> 1;
      if (arr[mid] == target) {
        return true;
      } else if (arr[mid] > target) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    }
    return false;
  }
}
```

- 有序数组中寻找大于（小于）等于目标值最左（右）侧位置

```java
public class findClosestIndex {
  public static boolean findClosestIndex(int[] arr, int target) {
    if (arr == null || arr.length <= 0) {
      return -1;
    }
    int left = 0, right = arr.length - 1;
		int index = -1;
    while (left <= right) {
      int mid = left + (right - left) >> 1;
      if (arr[mid] >= target) {
	      index = mid;
        right = mid - 1;
      } else {
        left = mid + 1;
      }
			//if (arr[mid] <= target) {
	    //  index = mid;
      //  left = mid + 1;
      //} else {
      //  right = mid - 1;
      //}
    }
    return index;
  }
}
```

- 局部最小值
    - 长度为1，arr[0]就是局部最小；
    - 数组的开头，如果arr[0] < arr[1] ，arr[0]被定义为局部最小。
    - 数组的结尾，如果arr[N-1] < arr[N-2] ，arr[N-1]被定义为局部最小。
    - 剩下就是数组下标1~N-2之间的了。再按arr[i-1] < arr[i] <arr[i+1] 找到一个局部最小。
    
    ```java
    public class findLessIndex {
      public static int findLessIndex(int[] arr) {
        if (arr.length == 0) {
          return -1;
        }
        // 长度为1或者arr[0] < arr[1]
        if (arr.length == 1 || arr[0] < arr[1]) {
          return 0;
        }
        // arr[N-1] < arr[N-2]
        if (arr[arr.length - 1] < arr[arr.length - 2]) {
          return arr.length - 1;
        }
        // 剩下的则在中间
        int left = 0, right = arr.length - 1;
        while (l <= R) {
          int mid = left + (right - left) >> 1;
          if (arr[mid] < arr[mid - 1] && arr[mid] < arr[mid + 1]) {
            return mid;
          } else if (arr[mid - 1] < arr[mid]) {
            right = mid - 1;
          } else {
            left = mid + 1;
          }
        }
    		// 找不到
        return -1;
      }
    }
    ```