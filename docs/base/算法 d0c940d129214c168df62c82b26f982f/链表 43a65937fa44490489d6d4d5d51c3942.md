# 链表

### 基本操作

- 获取链表长度
    
    ```java
    Node cur = head;
    int n = 0;
    while(cur!=null){
        n++;
        cur = cur.next;
    }
    ```
    
- 反转链表
    
    ```java
    Node n1 = head;//旧链表
    Node n2 = null;//新链表
    while(n1!=null){
        Node tmp = n1.next; //保存下一个节点
        n1.next = n2;//将新链表的后半部分接上
        n2 = n1;//更新新链表的头节点
        n1 = tmp;//更新旧链表
    }
    return n2;
    ```
    

### 相关题型

- **打印两个有序链表的公共部分**
- **删除倒数第K个节点**
    - 单链表
        - 定义变量k
        - 遍历一次，每次k-1；
            - k >0，K值无效
            - k=0，删除头节点
            - k<0
                - 从头开始遍历，每次k+1，当k=0时，当前的节点就是要删除节点的上一个结点。
    - 双链表
        - 注意last指针的重连
- **删除中间结点**
    - 分析问题得到：链表长度每增加2，要删除的节点就后移动一个节点
        - 快慢指针，一个倍速，一个两倍速，找到删除节点的上一个节点
- **删除a/b处的节点**
    - 先遍历一次，获取链表的长度
    - 先计算出删除哪个节点
        
        ```java
        n = (int)Math.ceil((double)(a * n) / (double) b);
        ```
        
    - 删除节点
        - 如果n==1，删除头节点；
        - 如果n>1，重头开始遍历，每次n-1，判断条件n≠1，找到删除结点的前一个节点。
- **反转链表和双向链表**
    
    ```jsx
    public Node reserveList(Node head){
        Node pre = null;
        Node next = null;
        while(head!=null){
            next = head.next;//保存下一个节点
            head.next = pre;//当前节点接上上一个的节点链
            (//如果是双向链表 head.last = next;)
            pre = head; //更新节点链
            head = next; //还原和更新头节点
        }
        return pre;
    }
    ```
    
- **反转部分单向链表**
    - 先判断是否满足1≤from≤to≤N，不满足直接返回头节点
    - 找到from-1和to+1的节点，将区间反转后，正确连接。
        - 如果from-1的节点为null，说明反转部分包含头节点
    
    ```java
    public Node reversePart(Node head,int from,int to){
    	int len = 0;
    	Node node1 = head;
    	Node fPre = null;
      Node tPos = null;
      while(node1!=null){ //计算链表长度同时查找fPre和tPos
        len++;
        fPre = len == from - 1 ? node1 : fPre;
        tPos = len == to + 1 ? node1 :tPos;
        node1 = node1.next;
      }
    	if(from>to||from < 1 || to > len){
    		return head;
    	}
      //判断区间内是否包含头结点，使node1指向区间的第一个结点
      node1 = fPre == null ? head : fPre.next;
      //定义node2记录下一个结点
      Node node2 = node1.next;
      //将node1的next接上区间后面的部分
      node1.next = tPos;
      Node next = null;
      //对node2开头的部分进行反转，最后node1为链表头
      while(node2!=tPos){
        next = node2.next;
        node2.next = node1;
        node1 = node2;
        node2 = next;
      }
      //如果反转区域不包含头结点，则需要将原链表前面部分连接上
      if(fPre != null){
        fPre.next = node1;
        return head;
      }
      //否则的话，返回新链头node1即可
      return node1;
    }
    ```
    
- **环形单链表的约瑟夫问题**
    - 普通解法
        - 如果链表为空 / 链接结点数为1 / m<1，直接返回。
        - 遍历节点，不断报数，到达m就删除该节点，知道剩下一个结点为止。
    - 进阶解法：直接确定哪一个是最后一个节点。
        - 给每个节点编号，老编号 = （新编号+m-1）%i+1。
        
        ```java
        //计算出存活人的编号
        public int getLive(int i,int m){
          if(i=1){
            return 1;
          }
          return (getLive(i-1,m)+m-1)%i+1;
        }
        ```
        
        - 找到该点，进行以下处理后，返回即可
        
        ```java
        //next指向自己
        head.next = head;
        ```
        
- **判断链表是否为回文结构**
    - 利用栈结构，如果回文，依次出栈后的与原链表相同
    
    ```java
    public boolean isPalindromel(Node head){
      Stack<Node> stack = new Stack<Node>();
      Node cur = head;
      while(cur != null){
        stack.push(cur);
        cur = cur.next;
      }
      while(head!=null){
        if(head.value!=stack.pop().value){
            return false;
        }
        head = head.next;
      }
      return true;
    }
    ```
    
    - 优化，压入一半即可。
        - 先用一二倍速指针找到右半区，将右半区的逐个压栈，然后逐个出栈比较。
    - 不使用栈和其他数据结构。
        - 将右半区进行反转，记录首尾两个节点，依次向中间逐个比对
        - 注意：无论true还是false，对要对链表进行还原
        
        ```java
        public boolean isPalindrome3(Node head){
            if(head ==null || head.next == null)
                return true;
            //找到中点
            Node n1 = head;
            Node n2 = head;
            while(n2.next!=null&&n2.next.next!=null){
              n1 = n1.next;  //n1->中部
              n2 = n2.next.next; //n2->尾部
           }
            n2 = n1.next; //n2->右半部第一个节点
            n1.next = null;  //mid.next->null;
            Node n3 = null;
            //对右半部分进行反转
            while(n2!=null){
                n3 = n2.next;
                n2.next = n1;
                n1 = n2;
                n2 = n3;
            }
            n3 = n1; //n3->保存最后一个节点
            n2 = head; //n2->第一个节点
            boolean res = true;
            while(n1 != null && n2 != null){
                if(n1.value!=v2.value){
                    res = false;
                    break;      
                }
            }
            //还原链表
            n1 = n3.next;
            n3.next = null;
            while(n1 != null){
                n2 = n1.next;
                n1.next = n3;
                n3 = n1;
                n1 = n2;
            }
            return res;
        }
        ```
        
- 将单链表按某值划分为左边小，中间相等，右边大的形式
    - 普通解法
        - 遍历链表获取长度N
        - 创建长度为N的Node类型数组nodeArr，遍历链表依次存进去
            - 不使用LinkedList或ArrayList结构，方便调整
        - 按题目要求进行顺序调整，即改进快速排序中partition的调整过程
        - 对nodeArr中节点进行重连