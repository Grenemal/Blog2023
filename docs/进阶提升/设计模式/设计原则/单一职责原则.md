# 单一职责原则

单一职责原则（SRP）：一个对象或方法，只做一件事情。

当两个职责耦合在一起的时候，一个职责发生变化可能会影响到其他职责的实现，造成意想不到的破坏，这种耦合性得到的是低内聚和脆弱的设计。

## 设计模式中的SRP

### 代理模式

图片预加载例子中，把添加img标签的功能和预加载图片的职责分开放到两个对象中，这两个对象各自都只有一个被修改的动机。在它们各自发生改变的时候，也不会影响另外的对象。

### 迭代器模式

对于迭代的对象可能是数组，可能是类数组，我们需要把遍历的过程抽离出来成each对象，以后还要增加新的迭代方式，我们只需要修改each方法即可。

### 单例模式

我们把管理单例的职责和创建登录浮窗的职责分别封装在两个方法里，这两个方法可以独立变化而互不影响，当它们连接在一起的时候，就完成了创建唯一登录浮窗的功能。

### 装饰者模式

装饰者模式可以为对象动态增加职责，从另一个角度来看，这也是分离职责的一种方式。

我们把数据上报的功能单独放在一个函数里，然后把这个函数动态装饰到业务函数上面。

## 何时应该分离

要明确的是，并不是所有的职责都应该一一分离。

一方面，如果随着需求的变化，**有两个职责总是同时变化，那就不必分离他们。** 比如在ajax请求的时候，创建xhr对象和发送xhr请求几乎总是在一起的，那么创建xhr对象的职责和发送xhr请求的职责就没有必要分开。

另一方面，职责的变化轴线仅当它们确定会发生变化时才具有意义，即使两个职责已经被耦合在一起，但它们**还没有发生改变的征兆，那么也许没有必要主动分离它们**，在代码需要重构的时候再进行分离也不迟。

## 违反SRP原则

在方便性与稳定性之间要有一些取舍。具体是选择方便性还是稳定性，并没有标准答案，而是要取决于具体的应用环境。

## 优缺点

SRP原则的优点是降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度，这**有助于代码的复用，也有利于进行单元测试**。当一个职责需要变更的时候，不会影响到其他的职责。

但SRP原则也有一些缺点，最明显的是会增加编写代码的复杂度。当我们按照职责把对象分解成更小的粒度之后，实际上也增大了这些对象之间相互联系的难度。