# 浏览器渲染原理

## 将HTML文件转化为DOM树

当我们打开一个网页时，都会去获取对应的HTML文件以及其他文件，大都是字符串。

但计算机硬件并不能理解这些字符串，在网络传输中其实都是`0和1`的`字节数据`，浏览器接收到字节数据之后，会转化为字符串，也就是我们写的代码。

当转化为字符数据之后，浏览器会先对其进行词法分析，转化为`标记（token）`。这个过程叫做`标记化`。

简单来说，标记是构成代码的最小单位，这个过程会将代码拆分为一块块，并作上标记，便于理解这一块代码是什么意思。

结束标记化后，会将这些标记转化为Node结点，最后这些node结点会根据不同结点之间的联系构建成一棵`DOM树`

当解析器发现有非阻塞资源，如一张图片等，会请求这些资源，然后继续解析，不会阻塞；但对于`<script>`标签（特别是没有`async`或者`defer`属性）会阻塞渲染并停止HTML的解析。

> 预加载器扫描提供的优化减少了阻塞。
> 预加载扫描器，将解析可用的内容并请求高优先级的资源，如`CSS`、`JavaScript`、`web`字体等。我们可以不用等到解析器找到外部资源的引用时再请求资源。它可以再后台检索资源，当HTML解析器到达请求的资源时，它可能已经在运行或被下载。

> `CSS`资源不会阻塞HTML，但会阻塞`JavaScript`，因为JavaScript经常用于查询元素的CSS属性。

> 当给`<script>`标签添加`defer`属性以后，该JS文件会并行下载，但会放在HTML解析完成后`顺序执行`，对于这种情况，可以将`script`标签放在任何位置，`defer`对模块脚本没有作用——他们默认 defer。
> 加上`async`属性，表示JS文件下载和解析不会阻塞渲染，会尽快加载并立即执行，所以多脚本可能会`乱序执行`，这对于不依赖任何脚本的脚本是非常合适的。

![](https://segmentfault.com/img/bVWhRl/view?w=801&h=814)

## 将CSS文件转化为CSSOM树

CSS对象模型与DOM是很相似的。

在开发中，我们应该尽可能避免写过于具体的CSS选择器，对于HTML来说，应该尽可能少的添加无意义标签，保证层级扁平。

构建CSSOM非常快，通常小于一次DNS查找所需的时间。

> CSS的求值过程：
> - filtering：匹配各个选择器中有效的属性值
> - cascading：对比选择器的特异性，生成层叠值
> - defaulting：判断层叠值是否为空。如果为空，使用继承或者初始值，生成不为空的指定值
> - resolving：将相对值计算成绝对值，（比如em转化成px，相对路径转化成绝对路径等），生成计算值
> - formatting：转化如vh，vw，百分比这种，得到使用值。
> - 将小数像素值转为整数
> - 完毕

## 生成渲染树

当我们生成DOM树和CSSOM树以后，就需要将两科树组合为`渲染树`。

渲染树只会包含显示的节点和这些节点的样式信息，如果某个节点的样式为`display:none`，那么不会显示在渲染树中。

在浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做`回流`），然后知道用GPU绘制，合成图层，像是在屏幕上。

## 为什么操作DOM慢

因为DOM是属于渲染引擎的东西，而JS又是JS引擎的东西，当我们用JS去操作DOM时，必定涉及到两个线程之间的通信，势必会带来一些性能上的损耗；操纵的次数一多，等同于一直在进行两个线程之间的通信，并且操作DOM可能还会带来重绘回流的情况，从而导致性能上的问题。

> 经典面试题：插入几万个 DOM，如何实现⻚面不卡顿?
> 解决问题的重点是：如何分批次地部分渲染DOM。
> 方案一：通过 requestAnimationFrame 的方式去循环的插入 DOM
> 方案二：虚拟滚动，只渲染可视区域内的内容，非可视区域的完全不渲染，当用户在滚动时，实时地替换渲染的内容。

## 重绘和回流

- 重绘：改变节点的外观而不影响布局
- 回流：布局或者几何属性需要改变

重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。

回流必定会发生重绘，但重绘不一定会引发回流。回流的成本比重绘高很多，改变子节点可能导致父结点的一系列回流。

以下几个动作可能会导致性能问题：
- 改变window大小
- 改变字体
- 添加或者删除样式
- 文字改变
- 定位或者浮动
- 盒模型 

重绘和回流也和`Event Loop`有关：
- 当执行完微任务时，会判断`document`是否需要更新，因为浏览器是`60Hz`的刷新率，所以16.6ms才会更新一次
- 然后判断是否有`resize`或者`scroll`事件，有的话触发事件，同样至少`16ms`才会触发一次，自带节流
- 判断是否触发了媒体查询
- 更新动画并且发送事件
- 判断是否有全屏操作
- 执行`requestAnimationFrame`回调
- 执行`IntersectionObserver`回调，该方法用于判断元素是否可见，可以用于懒加载，但兼容性不好
- 更新界面
- 以上为一帧内可能会做的事情，如果还有空闲时间，会去执行`requestIdleCallback`回调

减少重绘回流的手段：
- 使用`transform`代替`top`
- 使用`visibility`替换`display:none`，前者会引发重绘，但后者会引发回流
- 不要将节点的属性作为循环中的变量
- 不要使用`table`布局，一个小的改动可能会导致整个table重新布局
- 动画的实现速度也快，回流次数越多，可以选择使用`requestAnimationFrame`
- CSS选择符`从右往左`匹配查找，避免节点层级过多
- 将频繁重绘回流的节点设置为图层，图层可以阻止该节点的渲染行为影响别的节点。
	- 例如`video`、`iframe`标签
	- 将css设置为`will-change:xxx`(实验性功能)

## 如何提高页面渲染的速度

（在不考虑缓存和优化网络协议的前提下）

- 从文件大小上考虑
- 从script标签的使用上考虑
- 从CSS、HTML的代码书写上考虑
- 从下载的内容是否需要的首屏使用上考虑