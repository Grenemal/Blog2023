# HTTP详解

## 什么是HTTP

HTTP是超文本传输协议（`HyperText Transfer Protocol`）

- 协议
	- HTTP协议，我们可以认为是一个用在计算机世界里的协议，建立了一种计算机之间交流通信的**规范**，以及相关的各种控制和错误的处理方式。
- 传输
	- HTTP是一个双向协议，当我们在网上🏄🏻时，浏览器是请求方，百度是应答方，两者约定通过HTTP协议来通信，于是浏览器把请求信息发送给网站服务器，网站服务器再把一些数据返回给浏览器，来实现一次通信。
	- 数据在两边传输，但也允许中间有中转或者接力。中间人遵循HTTP协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。
- 超文本
	- 文本：互联网早期只是简单的字符文字，现在已经扩展为图片、视频、压缩包等
	- 超文本：文字、图片、视频的混合体，**最关键是有超链接**，能从一个超文本跳转到另外一个超文本。
	- HTML就是常见的超文本

总的来说， **HTTP 是一个在计算机世界里专⻔在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和 规范」。**

## 常见的HTTP状态码

[HTTP常见状态码](./相关问题/常见的状态码.md)

## 常见的HTTP字段
- Host
	- 指定服务器的域名
	- Host: www.A.com
- Content-Length
	- 服务器返回数据时，会有该字段，表示数据的长度
	- Content-Length: 1000
- Connection
	- 客户端要求服务器使用TCP持久连接，以便其他请求复用，HTTP/1.1 版本的默认连接都是持久连接
	- 为了兼容老版本的 HTTP，需要指定 Connection: Keep-Alive
- Content-Type
	- 用于服务器回应时，告诉客户端，本次数据是什么格式。
	- Content-Type: text/html; charset=utf-8
- Accept
	- 客户端请求时，可以设定`Accept`字段表示接受哪些数据格式；
	- Accept: `*/*`
- Content-Encoding
	- 数据的压缩方法。表示服务器返回的数据使用了什么压缩格式
	- Content-Encoding: gzip
- Accept-Encoding: gzip,deflate

## GET与POST

- 两者区别
	- GET是请求从服务器获取资源
	- POST是请求向URL指定的资源提交数据，数据放在body中
- 两者是否都是安全幂等的
	- 安全：请求方法不会破坏服务器上的资源
	- 幂等：执行多次相同的操作，结果都是相同的
	- GET方法是安全且幂等的
	- POST方法，会修改服务器上的资源，使用不安全，多次提交数据会创建多个资源，所以不是幂等的

## HTTP特性

### 优点
1. 简单

HTTP基本的报文格式就是`header & body`，头部信息也是`key:value`的形式，易于理解，降
低了学习和使用的门槛。

2. 灵活和易于扩展

HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。

同时HTTP工作在应用层，则它下层可以随意变化。

HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCP 层换成了基于 UDP 的 QUIC。

3. 应用广泛和跨平台

### 缺点

1. 无状态——双刃剑

好处：服务器不会去记录HTTP的状态，所以不需要额外的资源来记录状态信息，减轻服务器的负担

坏处：没有记忆功能，在完成有关联性的操作时会非常麻烦

> **使用cookie控制客户端状态**
> - 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。
> - 在客户端第一次请求后，服务器会下发一个装有客户信息的cookie，后续客户端请求服务器的时候，带上cookie，服务器就能认得了。

2. 明文传输——双刃剑

明文意味着在传输过程中的信息，是可方便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。

但也意味着所有信息都可以被查看，很容易被窃取。

3. 不安全（最大的问题）
- 通信使用明文(不加密)，内容可能会被窃听。
- 不验证通信方的身份，因此有可能遭遇伪装。
- 无法证明报文的完整性，所以有可能已遭篡改。

HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。

### HTTP/1.1性能

HTTP协议基于TCP/IP，并且使用了「请求-应答」的通信方式

1. 长连接

HTTP/1.1提出了`长连接`的通信方式，也叫持久连接，好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。

只要没有任意一段明确提出断开连接，则保持TCP连接状态。

2. 管道网络传输

HTTP/1.1 采用了⻓连接的方式，这使得管道(pipeline)网络传输成为了可能。

即可在同个TCP连接里面，客户端可以发送多个请求，只要第一个请求发出去了，就可以接着发送第二个请求，可以**减少整体的响应时间**。

但服务器还是得按顺序，但前面的回应特别慢，后面的就会需要排队等待，称队头堵塞。

3. 队头阻塞

「请求 - 应答」的模式加剧了 HTTP 的性能问题。

因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致 客户端一直请求不到数据，这也就是「`队头阻塞`」。

总之 HTTP/1.1 的性能一般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能。

### HTTPS

> `HTTP`与`HTTPS`的区别
> 1. HTTP是超文本传输协议，信息是明文传输，**存在安全风险的问题**。HTTTPS则是解决HTTP不安全的问题。在TCP和HTTP之间**加入了SSL/TLS安全协议**，使得报文能加密传输。
> 2. HTTP连接建立相对简单，TCP三次握手之后便可以进行HTTP的报文传输，而HTTPS在TCP三次握手之后，**还需要进行SSL/TLS的握手过程**，才能进入加密报文传输。
> 3. HTTP的端口号是80，**HTTPS的端口号是443**
> 4. HTTPS**需要向CA(证书权威机构)申请数字证书**，来保证服务器的身份是可信的。

- HTTPS解决了哪些问题
	1. 信息加密：交互信息无法窃取
	2. 校验机制：无法篡改通信内容，篡改了就不能正常显示
	3. 身份证书：可以证明是真实的网站

#### 如何实现

1. 混合加密

通过混合加密的方式可以保证信息的机密性，解决了窃听的风险

> 对称加密和非对称加密
（1） 对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。
（2） 非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。
（3） 解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。

HTTPS采用的是`对称加密`和`非对称加密`结合的**混合加密**方式：

在通信建立前采用**非对称加密**的方式交换会话秘钥，服务器把公钥A发送给浏览器，**浏览器随机生成一个用于对称加密的秘钥X**，用公钥A对X进行加密传回服务器，服务器用私钥B进行解密，得到秘钥X，这样子两边都有秘钥X，而别人无法知道它，**在之后的通信中，使用秘钥X对数据进行加密解密**。

2. 摘要算法

摘要算法用来实现完整性，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的⻛险。

客户端在发送明文之前会通过摘要算法算出明文的「指纹」，**发送的时候把「指纹 + 明文」一同加密成密文后，发送给服务器**，服务器解密后，用相同的摘要算法算出发送过来的明文的「指纹」，通过**比较客户端携带的「指纹」和当前算出 的「指纹」**，若「指纹」相同，说明数据是完整的。

3. 数字证书

如何保证公钥不被篡改和信任度?

借助第三方权威机构 CA (数字证书认证机构)，将服务器公钥放在数字证书(由数字证书认证机构颁发)中，只要证书是可信的，公钥就是可信的。

服务器把自己的公钥注册到CA，CA用自己的私钥将服务器的公钥进行数字签名，并颁发数字证书。建立通信之前，服务器先返回公钥和CA数字签名给客户端，客户端拿到数字签名后，使用CA的公钥（已经事先注入到浏览器或者系统中）进行确认数字证书的真实性，从数字证书获取到服务器的公钥后，使用它对报文加密后发送，服务器使用私钥进行解密。

#### SSL/TLS协议

基本流程：
- 客户端向服务器索要并验证服务器的公钥
- 双方协商产生「会话秘钥」
- 双方采用「会话秘钥」进行加密通信。

前两步就是『握手阶段』，共涉及4次通信：

1. 首先，客户端向服务器发起加密通信请求，也就是`ClientHello`

这一步，客户端主要向服务器发送一下内容
- 客户端支持的SSL/TLS协议版本
- 客户端生成的随机数（`ClientRando`），用于后面产生「会话秘钥」
- 客户端支持的密码套件列表，如RSA加密算法

2. 服务器收到客户端请求后，作出响应，也就是`ServerHello`

服务器回应的内容有：
- 确认SLL/TLS协议版本，如果浏览器不支持，则关闭加密通信
- 服务器生成的随机数（`ServerRandom`），用于后面生产「会话秘钥」
- 确认密码套件，如RSA加密算法
- 服务器的数字证书

3. 客户端收到回应后，首先通过浏览器（或者操作系统）中的CA公钥，确认服务器的数值证书的真实性，如果证书没有问题，客户端会从数字证书中取出服务器公钥，然后使用它加密报文。

向服务器发送一下信息：
- 一个随机数（`pre-master-key`），随后会被服务器公钥加密。
- **加密通信算法改变通知**，表示随后的信息都会将用「会话秘钥」加密通信。
- **客户端握手结束通知**，表示客户端握手阶段已经结束，这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。

此时服务端和客户端就同时有三个随机数，接着有双方协商的加密算法，**各自生成**本次通信的「会话秘钥」。

4. 服务器收到客户端第三个随机数后，通过协商的加密算法，计算出本次通信的「会话秘钥」。

然后向客户端发送最后的信息：
- **加密通信算法改变通知**，表示随后的信息都将用「会话秘钥」加密通信。
- **服务器握手结束通知**。表示服务器握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。

至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过**用「会话秘钥」加密内容**。

### HTTP协议的演变

#### HTTP/1.1

- 使用TCP长连接改善了短连接造成的性能消耗
- 支持管道网络通信，只要一个请求发送出去了，就可以发送第二个，减少整体的响应时间。

性能瓶颈：
- 请求头未压缩就发送，**首部信息越多延迟越大**，只能压缩`Body`部分
- 发送冗余的首部。每次互相发送**相同的首部**造成浪费。
- 服务端是顺序响应的，可能造成队头阻塞
- 没有优先级控制
- 请求只能从客户端开始，服务器只能被动请求

#### HTTP/2

HTTP/2是基于HTTPS的，使用安全性也是有保障的。

- 头部压缩
	- 如果同时发出多个请求，他们的头是一样或者类似的，那么会消除重复的部分
	- 也就是所谓的`HPACK`算法：在客户端和服务端同时维护一张表，所有字段都会存入这张表，生成一个索引号，以后就不发送同样字段了**只发送索引号**，这样就提高速度了。
- 二进制格式
	- 全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧：头信息帧和数据帧，对计算机友好，无需再将明文的报文转换成二进制，而是**直接解析二进制报文，提高了数据传输的效率**
- 数据流
	- HTTP/2中的数据包不是按顺序发送的，同一连接里连续的数据包，可能属于不用的响应。因此必须要对数据包进行标记，指出它属于哪个响应。
	- 每个请求或响应的所有数据包，称为一个`数据流`。每个数据流都标记着一个独一无二的编号，其中规定**客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数**。
	- **客户端还可以指定数据流的优先级**。优先级高的请求，服务器就先响应该请求。
- 多路复用
	- HTTP/2是可以在一个连接中并发多个请求或响应，而不用按照顺序一一对应。
	- 移除了HTTP/1.1中串行请求，不需要排队等待，**降低了延迟，大幅度提高了连接的利用率**。
	- 举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就 回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。
- 服务器推送
	- 可以主动向客户端发送消息。
	- 举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是`服务器推送`(Server Push，也叫 Cache Push)。

#### HTTP/3

HTTP2主要问题在于，多个HTTP请求在复用一个TCP连接，下层的TCP协议不清楚有多少个HTTP请求。**一旦发生丢包，就会触发TCP的重传机制**，这样子一个TCP连接中的所有HTTP请求都必须**等待**这个丢了的包被重新传回来。
- HTTP/1.1中管道传输如果一个请求阻塞，队列后的请求也都阻塞了
- HTTP/2多个请求复用同个TCP连接，一旦发生丢包，就会阻塞所有的HTTP请求。

这些都是基于TCP传输层的问题，所以**HTTP/3把HTTP下层的TCP协议改成了UDP**！

UDP 发生是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的一个丢包全部重传问题。

但UDP是不可靠传输的，但基于UDP的`QUIC协议`可以实现类似TCP的可靠性传输。
- QUIC协议有自己的一套机制来保证传输的可靠性。当某个流发生丢包时只会阻塞这个流，**其他流不会受到影响**
- TLS3升级了最新的1.3版本，优化了过程，只需要 1 个 RTT 往返时延，也就是**只需要 3 次握手**；头部压缩算法也升级为`QPark`
- HTTPS要建立一个链接，需要花费6次交互，先建立3次握手，然后是TLS/1.3的3次握手。QUIC直接将以往的TCP和TLS/1.3的六次交互合并成3次，减少了交互次数。

所以， QUIC 是一个在 UDP 之上的`伪 TCP + TLS + HTTP/2` 的多路复用的协议。

QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题。所以HTTP/3 现在普及的进度非常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。

![image](https://cdn.jsdelivr.net/gh/Merlin218/image-storage@master/picX/image.3bg4wj20mk3k.jpg)