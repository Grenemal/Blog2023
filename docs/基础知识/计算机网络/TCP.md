# TCP

## TCP基本认识

### 为什么需要TCP

IP层是不可靠的。他不能保证网络包的交付、不保证网络包的按序交付，也不保证网络包中的数据完整性。

### 什么是TCP

TCP是一个工作在传输层的可靠数据传输服务，它能确保接受端接收的数据是**无损坏、无间隔、非冗余和按序的**。
- 面向连接：**连接必须是一对一的**，无法像向UDP一样一个主机同时向多个主机发送消息；
- 可靠的：无论网络链路中出现了怎样的链路变化，TCP都**可以保证一个报文一定能到达接收端**；
- 字节流：无论消息有多大，都可以进行传输，并且消息是「 有序 」的，及时先收到后面的字节，也不能交给应用层处理，同时会对「 重复 」的报文会自动丢弃。

### TCP连接

建立一个TCP连接，需要客户端和服务端达成上述三个信息的共识：
- Socket：由IP地址和端口号组成
- 序列号：用来解决乱序的问题
- 窗口大小：用来做流量控制

> 唯一确定一个TCP连接：源地址、源端口、目的地址、目的端口（四元组）
> 源地址和目标地址在IP头部，作用是通过IP协议发送报文给对方主机。
> 源端口和目的端口是在TCP头部，作用是告诉TCP协议应该把报文发送给哪个进程。

最大TCP连接数 = 客户端的IP数 X 客户端的端口数

对于IPv4，客户端的IP数最多为2^32，客户端的端口最多为2^16，所以服务端单机最大TCP连接数，理论上约为2^48。

当然，服务端最大并发TCP连接数远不能达到理论上限：
- 文件描述符限制，Socket都是文件，所以首先要通过`ulimit`配置文件描述符的数目
- 内存限制，每个TCP连接都要占用一定内存，操作系统的内存是有限的

### TCP头格式

![](https://cdn.jsdelivr.net/gh/Merlin218/image-storage/picGo/202203201506705.png)

- 序列号
	- 建立之初计算机生成的随机数作为初始值，通过`SYN`包传给接收端主机，**每次发送一次数据，就累加一次该数据字节数的大小。用来解决网络包乱序。**
- 确认应答号
	- 指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为这个序号之前的数据都已经被正常吸收，**用来解决不丢包的问题。**
- 控制位
	- `ACK`：该位为1时，「确认应答」的字段变为有效
		- TCP规定，除了最初建立连接时`SYN`包，该为必须设置为1。
	- `RST`：该位为1时，表示TCP连接中出现异常必须强制断开连接。
	- `SYN`：该位为1时，表示希望建立连接，并将「序列号」作为初始值。
	- `FIN`：该位为1时，表示今后不会再用数据发送，表示断开连接
		- 当通讯结束希望断开连接时，通信双方的主机之间就可以交换`FIN`位为1的TCP段。

## TCP连接建立

### 三次握手过程和状态变迁

TCP是面向连接的协议，使用TCP之前必须先建立连接，而建立连接是通过**三次握手**来进行的。

![](https://cdn.jsdelivr.net/gh/Merlin218/image-storage/picGo/202203201710581.png)

- 一开始，客户端和服务端都处于`Closed`状态，先是服务端主动监听某个端口，处于`Listen`状态
- 第一次握手：客户端会随机初始化序号（seq = x），填入在头部的「序号」中，同时将`SYN`设置为1，表示SYN报文。接着发送给服务端，表示向服务端发起连接。该报文不包含应用层数据，之后客户端处于`SYN-SENT`状态。
- 第二次握手：服务端接收到客户端`SYN`报文后，首先服务端也随机初始化自己的序号（seq = y），填入头部的「序号」中，其次「确认应答号」填入「收到的SYN报文中的序号 + 1」，接着把`SYN`和`ACK`都标为1。接着把报文发送给客户端，该报文也不包含应用层数据，之后服务端处于`SYN-RCVD`状态。
- 第三次握手：客户端接收到服务端报文后，还需要回应最后一个应答报文，首先，该应答报文TCP首部`ACK`标志设置为1，其次「确认应答号」填入「收到的SYN报文中的序号 + 1」，最后将报文发送给服务端，**这次报文可以携带客户端到服务端的数据**，之后客户属于`ESTABLISHED`状态。
- 服务端收到报文之后，也进入`ESTABLISHED`状态。

> 通过`netstat -napt`命令，可以查看TCP的连接状态
> ![](https://cdn.jsdelivr.net/gh/Merlin218/image-storage/picGo/202203201736927.png)

**为什么是三次握手？不是两次或者四次？**

- 防止旧的重复连接初始化造成混乱
	- 假如说存在网络阻塞，第一个包由于没发出去，导致超时重新发送，那么旧的报文应该失效，那如果服务端还是先收到了旧的报文，然后返回了第二个报文，那么客户端根据上下文比较发现「确认应答号」不符合预期，那么就会发送`RST`报文终止连接。接着新的报文到达服务端，正确的进行了三次握手，建立了连接。
	- 如果只有两次握手的话，无法判断当前连接是否是历史连接，而三次握手则可以在客户端准备发送报文的时候，有足够的上下文去判断当前连接是否是历史连接。
- 同步双方初始序列号
	- TCP协议的通信双方，都必须维护一个「序列号」，序列号是可靠传输的一个关键因素
		- 接收方可以去除重复的数据
		- 接收方可以根据数据包的序号按序接收
		- 可标识发送出去的包，哪些是已经被对方接收的
	- 四次握手也可以可靠的同步双方的初始化序号，但第二步和第三部已经优化成一步，也就成了「三次握手」，而两次握手只能保证一方的初始化序列号被对方成功接收，无法保证双方的初始序列号都被确认接收。
- 避免资源浪费
	- 回到网络阻塞的例子，如果只有两次握手，那么服务端不清楚客户端是否收到自己发送出去的`ACK`确认信号，所以只能每收到一个`SYN`报文就主动建立一个连接，导致多个冗余的无效连接，造成不必要的资源浪费。

不使用「两次握手」和「四次握手」的原因: 
- 「两次握手」:无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号;
- 「四次握手」:三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。

## TCP Vs UDP